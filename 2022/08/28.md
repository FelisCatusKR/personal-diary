## 감사일기

- 나: 스트레스들을 잘 이겨내고 주말을 끝낸 나에게 감사
- 타인: 합이 잘 안 맞아도 끝까지 자리를 뜨지 않고 같이 활동해 준 Koala에게 감사
- 물질: 피\*마루 치즈폭탄피자에 감사
- 경험: 어려운 사람을 도울 수 있는 기회를 받은 하루에 감사

## 오늘 배운 것

- Javascript
  - 인터넷에서 자주 본 Javascript meme 중 하나를 분석해 보았음

![patricio](https://user-images.githubusercontent.com/25482893/187078221-87af9f88-8812-463b-bbe4-f52f1b44815a.png)

### 애초에 왜 서로 다른 타입의 객체(혹은 변수)끼리의 비교가 됨?

- 왜인지는 모르겠지만, Javascript에선 이런 서로 다른 객체에 대한 비교 연산을 위해 이미 스펙이 정해져 있음...
  - [The Abstract Relational Comparison Algorithm](https://262.ecma-international.org/5.1/#sec-11.9.3) 참조
  - 하단에 나오는 규칙들은 최대한 이 스펙을 참조하였으나, 자습을 통하여 공부하였기 때문에 정확하지 않을 수 있음
- 간단히 요약하자면, 개발자의 '편의'를 위해 shadow casting이 일어난다고 함......
- shadow casting으로 인해 일어나는 몇몇 '사고'를 방지하기 위해 `===` 이라는 연산자와 `!==` 이라는 연산자가 추가로 정의되어 있음...
  - 놀랍게도 이 또한 완벽하지 않다는 이야기를 들은 것 같은데, 이건 다음에 찾아보는 걸로...

### `0 == "0"` => `true`

- 서로 다른 타입의 변수는 `==` 비교연산자를 통해 비교가 되기 전에 한 쪽으로 cast 됨
  - 숫자와 숫자문자열 간 비교의 경우, 문자열을 숫자로 변환 `
  - 이 경우 `"0"` 이 `0` 으로 변환됨
- `0` 과 `0` 은 같음, 따라서 `true`

### `0 == []` => `true`

- 여기서부터 골때림... 일단 서로 다른 타입이므로 한 쪽으로 변환이 이루어지긴 함... 그럼 어떻게?
  - 하나의 피연산자가 객체이고 나머지 피연산자가 숫자인 경우, 객체를 `Number()` 를 이용해 변환하는 듯?
  - `Number([])` 의 결과는 0임, 따라서 `[]` 은 `0` 으로 변환됨
- `0` 과 `0` 은 같음, 따라서 `true`

### `"0" == []` => `false`

- '수학적인' 삼단 논법에 의하면, 앞의 두 명제가 참이니까 두 명제를 조합한 것도 참이겠지? 하지만 아니다...
  - 앞선 두 '명제'는 숫자와 다른 타입을 비교하였기 때문에, 숫자 쪽으로 피연산자가 변환되었음
  - 하지만 이번 비교식은 숫자가 없음... 따라서 숫자로 cast 되는 과정이 없어서 전혀 양상이 달라짐
- 그렇다면 이 식은 어떻게 변하는 걸까?
  - 하나의 피연산자가 객체이고 나머지 피연산자가 문자열인 경우, 객체가 `toString()` 을 이용해 변환됨
  - `toString([])` 의 결과는 `'[object Undefined]'` 임, 따라서 `[]` 은 `'[object Undefined]'` 으로 변환됨
- `"0"` 과 `'[object Undefined]'` 은 다름, 따라서 `false` ...

### 결론

Javascript는 정말 어썸하다...

## 오늘의 홈메이드 칵테일

출근 전날이라 술을 참았다. 잘 했다 나!
